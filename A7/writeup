Fun story. I got the code working to decrypt the shellcode finally. Took a long time. But I was storing the length of hte messsage just in front of the encrypted shellcode itself in a byte. When it was all working, it occurred to me that one byte was not sufficient to store the length of the shellcode, as thta allows a maximum of 256 bytes. 2 bytes would be better as that would allow for 64k. So I changed it from db 0x65 to db 0x65,0x0. It then stopped working correctly. It would decrypt the first five or so bytes and the rest was gibberish. 

This turned out to be a very hard bug to figure out. Everything seemed to be fine. I finally dug int where it xor'd all the bytes together and examined the ciphertext and the key. I finally realized that the ciphertext had the first few bytes correct, and then it started over. That is, about 6 bytes in, it started in with the first, second, etc byte. I checked it out in objdump and sure enough, it was repeated. But it was not that way in the source asm file. The only thing I could figure was that the byte 0x65 was a full instruction, so it was happy with that. However 0x65,0x00 was not a full instruction, so it repeated bytes over in order to complete instructions. 

Does anyone know why it does that? Is there anyway to turn it off? I realize that the application of what we are doing here is obscure and not really the supported way that it is supposed to work. You really aren't supposed to store data in and among instructions in the text section. I suppose it is an unsupported way of coding in assembly and thus is has unpredictable behavior. If anyone has any insight, please let me know and I will post an update.

My solution to this problem was to hardcode the length, as I am dynamically generating the code anyway, so I can just paste it in. Also, I didn't realize that this was going on, but I had noticed some ofthe issue with the other code, as I had to put nops after the data, as I had noticed that it was jumping into garbage instructions in and around the data. So that is how I dealt with it for those chunks of embedded data.

